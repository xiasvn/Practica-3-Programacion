# -*- coding: utf-8 -*-
"""Practica3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D0-z0fkTHVPTxySaPY-rdotyHShyEkWo
"""

import pandas as pd

class DirectedGraph:
    """Clase que genera una grafica dirigida"""
    def __init__(self):
        self.nodes = [0]  # Creamos un lista que nos guardara los nodos generados
        self.edges = {}   # Creamos un diccionario para guardar los arcos

    def len_edges(self):
        """Devuelve la cantidad de arcos en nuestra grafica"""
        return len(self.edges)

    def len_nodes(self):
        """Devuelve la cantidad de nodos en nuestra grafica"""
        return len(self.nodes)

    def agregar_nodo(self, node):
        """Agrega un nodo a la grafica"""
        self.nodes.append(node)

    def agregar_arco(self, arc, peso):
        """Agrega un arco al diccionario donde estan los arcos generados en la grafica"""
        self.edges[arc] = peso


class Trie:
    """Clase que genera un objeto de tipo arbol"""
    def __init__(self, arch_excel):
        self.arch_excel = arch_excel
        self.arbol = DirectedGraph()  # Crear una instancia de DirectedGraph

    def leer_archivo(self):
        """Lee los datos de un archivo Excel"""
        try:
            arch = pd.read_excel(self.arch_excel, dtype={'Binary coding': str}) #Nos lee elarchivo y lo cambia de formato para que podamos ver los elementos si alteraciones.
            return arch
        except FileNotFoundError: #Si dectecta un error en donde no se encuentre el archivo manda el mensaje.
            print("El archivo no fue encontrado.")
            return None
        except: #Si encuentra un error de otro tipo, mada el mensaje.
            print("Se produjo un error al leer el archivo, checa que sea de tipo Excel.")
            return None

    def guardar_datos_en_un_diccionario(self):
        """Guarda los datos del archivo Excel en un diccionario"""
        datos = self.leer_archivo() #Trae los datos del archivo
        if datos is not None: #Checa si hay algo
            letras = datos["Letters"] #Guarda lo datos que estan en la columna de Letters
            binarios = datos["Binary coding"] # Guarda los datos que estan el la columna Binary coding
            diccionario = dict(zip(letras, binarios)) #Generamos nuestro diccionario
            return diccionario
        else:
            return None #Si esta vacio no nos regresa nada

    def construir_arbol(self):
        """Construye el árbol a partir del alfabeto"""
        diccionario = self.guardar_datos_en_un_diccionario() #Traer a nuestro diccionario que acabamos de generar
        if diccionario is not None: #pregunta si el diccionario no esta vacio
            nodo_raiz = 0 #Empieza el contador, este nos va a ayudar a saber en que nodo estamos y quien esta conectado con este.
            proximo_nodo = 1 #Nos va guardando la informacion de quien es el nodo que sigue en la cuenta
            for clave, codigo in diccionario.items():
                nodo_actual = nodo_raiz #Este es nuestro contador es decir empieza en 0 y se reinicia cada que acaba el siguiente for
                for i, bit in enumerate(codigo):
                    arco_existente = False #Al inicio nunca vamos a tener un arco en nuestro diccionario entonces le decimos que no existe
                    for arco, peso in self.arbol.edges.items():
                        if arco[0] == nodo_actual and peso == bit: #checamos si ya existe nuestro arco para no poner un arco igual
                            nodo_actual = arco[1] #Seguimos con el contador
                            arco_existente = True
                            break

                    if not arco_existente: #Le preguntamos si e arco no existe
                        if i == len(codigo) - 1:#Checamos nuestro conteo ya es igual a la longitud de nuestro codigo -1
                            self.arbol.agregar_arco((nodo_actual, clave), bit) #Esto porque si cumple el if queremos que nos guarde al numero anterior y a la letra
                            self.arbol.agregar_nodo(clave) #Y agregamos la letra a nuestra lista de nodos
                            nodo_actual = proximo_nodo  #Guardamos en que nodo ahora estamos parado
                        else:
                            while (nodo_actual, proximo_nodo) in self.arbol.edges: #Aqui repetimos el proceso hasta que nuestro arco este en el diccionario
                                proximo_nodo += 1 #Nuestro contador aumenta
                            self.arbol.agregar_arco((nodo_actual, proximo_nodo), bit) #Agragemos al arco a al diccionario
                            self.arbol.agregar_nodo(proximo_nodo) #Agregamos al nodo a la lista de nodos
                            nodo_actual = proximo_nodo #Guardamos en que nodo estamos en este momento
                            proximo_nodo += 1 #SEguimos aumentando el contador
            return self.arbol.nodes, self.arbol.edges #regresamos a nuestra lista de nodos y a nuestro diccionario de arcos

    def traduccion_letras_a_numeros(self, letra):
        """Traduce letras a números"""
        traduccion_numero = [] #Vamos a guardar nuestro mensaje posteriormente

        def buscar_valor_recursivo(letra):
            for clave, valor in self.arbol.edges.items():
                if letra == clave[1]:
                    valor_letra = valor
                    traduccion_numero.append(valor_letra)
                    siguiente_letra = clave[0] #nos da quien es el nodo en el que esta
                    if siguiente_letra != 0: #checa si ya llego al nodo 0
                        buscar_valor_recursivo(siguiente_letra) #Llamamos a la funcion que busca a la siguiente letra en el diccionario de arcos

        buscar_valor_recursivo(letra) #Llamamos a la funcion que busca a la letra en el diccionario de arcos
        return traduccion_numero[::-1] #Nos regresa la letra traducida e invertida, para que la de bien traducida

    def traduccion_numeros_a_letras(self, codigo):
        """Traduce números a letras de acuerdo a nuestro alfabeto"""
        mensaje = [] #Aquí vamos a guardar nuestro mensaje posteriormente
        nodo_actual = 0 #empezamos el contador
        for digito in codigo: #lo vamos a repetir la cantidad de digitos que tenga el codigo
            arco_existente = False #Es como nuestro chequeo
            for arco, peso in self.arbol.edges.items(): #iteramos en el diccionario de arcos
                if arco[0] == nodo_actual and peso == digito: #checamos si ya esta el arco definido
                    if isinstance(arco[1], str): #checamos si ya llegamos a una letra
                        mensaje.append(arco[1])
                        nodo_actual = 0
                        arco_existente = True
                    else:#si no hemos llegado a una letra seguimos con el contador
                        nodo_actual = arco[1]
                        arco_existente = True
                    break

        return mensaje #nos regresa el mensaje traducido


def juntar_mensaje(lista):
        """Junta los elementos de una lista en una sola cadena"""
        cadena = ''.join(lista) #La función join nos ajuda a juntar todos los elementos de una lista en una sola cadena
        return cadena


def main(): #Creamos a la funcion principal
    arch = '/content/Code.xlsx'#Guardamos en un variable nuestro documento que trae toda la informacion para construir nuestro arbol
    trie = Trie(arch) #Creamos un objeto de tipo Trie
    nodos, arcos = trie.construir_arbol() #Llamamos a la atributo que nos va a construir el arbol. Esta nos devuelve la lista de nodos que se generaron y el diccionario de arcos que se genraron
    mensaje = [] #Generamos una lista vacio en donde porsteriormente guardaremos nuestro mensaje
    print('Opciones') #Imprimimos esto como si fuera un menu para ser amigable con el usuario
    print('1. Traducir números a mensaje')
    print('2. Traducir mensaje a números')
    tipo_de_traduccion = input('Elige alguna opción de las anteriores (solo digita 1 o 2): ') #Le pedimos que eliga una de las dos opciones
    if tipo_de_traduccion == '2':
        letra = input('Ingrese código a traducir: ')#Le pedimos el mensaje que quiere traducir
        mensaje = []
        for x in letra: #vamos a llama al atributo de trie las letras que tenga la palabra
            lista_con_mensaje_numeros = trie.traduccion_letras_a_numeros(x) #Nos va a ir traduciendo letra por letra
            mensaj = juntar_mensaje(lista_con_mensaje_numeros)
            mensaje.append(mensaj)
        print('Mensaje en números es:', juntar_mensaje(mensaje)) #al final nos va a dar todos los numero juntos
    elif tipo_de_traduccion == '1':
        numero = input('Ingrese código a traducir: ') #Le pedimos el mensaje que quiere traducir
        lista_con_mensaje_letras = trie.traduccion_numeros_a_letras(numero) #Llamamos al atributo de Trie que nos traduce nuestro mensaje
        print(juntar_mensaje(lista_con_mensaje_letras))#al final nos va a dar todos los letras juntas
    else:
        print('Lo lamentamos, solo tenemos esas dos funciones') #Si eligen otra opcion les saldra este mensaje

main()